# 一、DNS

## 1.DNS 协议的概念

**概念**:DNS是域名系统(Domain Name System)的缩写，提供的是一种主机名到IP地址的转换服务，就是我们常说的域名系统。它是一个由分层的DNS服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。

**作用**:将域名解析为IP地址，客户端向DNS服务器(DNS服务器有自己的IP地址)发送域名查询请求，DNS服务器告知客户机Web服务器的IP地址。

## 2.DNS同时使用TCP和UDP协议

 **DNS占用53号端口，同时使用TCP和UDP协议。**

1. 在区域传输的时候使用TCP协议
   - 辅域名服务器会定时(一般3小时)向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。
   - 区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。
2. 在域名解析的时候使用UDP协议
   - 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

## 3.DNS完整的查询过程

**DNS服务器解析域名的过程：**

1. 首先在**浏览器缓存**中查找对应的**IP地址**，如果查找到直接返回，若找不到继续下一步
2. 将请求发送给**本地DNS服务器**，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
3. 本地DNS服务器向**根域名服务器**发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
4. 本地DNS服务器向**顶级域名服务器**发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
5. 本地DNS服务器向**权威域名服务器**发送请求，域名服务器返回对应的结果
6. 本地DNS服务器将返回结果保存在缓存中，便于下次使用
7. 本地DNS服务器将返回结果返回给浏览器

## 4.迭代查询与递归查询

- 递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求,最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。
- 迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出多次的查询请求。

## 5.DNS记录和报文

DNS服务器中以资源记录的形式存储信息，每一个DNS响应报文一般包含多条资源记录。一条资源记录的具体的格式为
(Name，Value，Type，TTL)
其中TTL是资源记录的生存时间，它定义了资源记录能够被其他的 DNS服务器缓存多长时间。
常用的一共有四种Type 的值，分别是A、NS、CNAME和MX，不同Type的值，对应资源记录代表的意义不同。

1. 如果Type = A，则Name是主机名，Value是主机名对应的IP地址。因此，一条记录为A的资源记录，提供了标准的主机名到IP地址的映射。
2.  如果Type = NS，则Name是个域名，Value是负责该域名的DNS服务器的主机名。这个记录主要用于DNS链式查询时，返回下一级需要查询的 DNS服务器的信息。
3. 如果 Type = CNAME，则Name为别名，Value为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名对应的规范主机名，从而告诉查询主机去查询这个主机名的IP地址。主机别名主要是为了通过给一些复杂的主机名提供一个便于记忆的简单的别名。
   4.如果Type = MX，则Name为一个邮件服务器的别名，Value为邮件服务器的规范。

# 二、网络模型

## 1.OSI七层模型

![img](计算机网络.assets/1604024701811-7ac177bc-d649-45b8-8646-53af8f18a0de.webp)

1. 应用层

   0SI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有:**HTTP ,HTTPS,FTP，POP3、SMTP**等。

   - 在客户端与服务器中经常会有数据的请求，这个时候就是会用到 **http(hyper text transfer protocol)(超文本传输协议)**或者**https** ,在后端设计数据接口时，我们常常使用到这个协议。
   - **FTP**是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如百度网盘`迅雷应该是基于此协议的。
   - **SMTP**是simple mail transfer protocol(简单邮件传输协议)。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。

2. 表示层

   表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。
   例如，**IBM**主机使用**EBCDIC**编码，而大部分**PC**机使用的是**ASCII** 码。在这种情况下，便需要表示层来完成这种转换。如果您想要用尽量少的词语来记住这第6层，那就是“一种通用的数据格式”。
   在项目开发中，为了方便数据传输，可以使用base64对数据进行编解码。如果按功能来划分，base64应该是工作在表示层。

3. 会话层

   会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。

4. 传输层

   传输层建立了主机端到端的链接，传输层的作用是**为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题**。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，**TCP、UDP**就是在这一层。端口号既是这里的“端”。

5. 网络层

   本层通过**IP寻址**来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的工P层。这一层就是我们经常说的IP协议层。IP协议是Internet 的基础。我们可以这样理解，**网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式**。

6. 数据链路层

   将比特组合成字节,再将字节组合成帧,使用链路层地址(以太网使用MAC地址)来访问介质,并进行差错检测。
   网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，**在数据链路层上还增加了差错控制的功能**。

7. 物理层

   实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有(各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。

**OSI七层模型通信特点:对等通信**

对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。

## 2.TCP/IP五层协议

TCP/IP五层协议和OSI七层协议对应的关系如下

![img](计算机网络.assets/1604025489154-966a96f5-1c8e-4d03-b9f9-f51250f63a22.png)

- **应用层(application layer)**:直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如HTTP协议(万维网服务)、FTP协议(文件传输)、SMTP协议(电子邮件)、DNS(域名查询)等。
- **传输层(transport layer)**:有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议:
  - 传输控制协议(Transmission Control Protocol，TCP):提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段(segment) ;
  - 用户数据报协议(User Datagram Protocol，UDP):提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。
- **网络层(internet layer)**:有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。
- **数据链路层(data link layer)**:负责将网络层交下来的IP数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息(如同步信息、地址信息、差错控制等)。
- **物理层(physical Layer)**:确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。

**每一层都对应着不同的设备**

![img](计算机网络.assets/1604025001463-47398363-0ab1-4bcf-b247-5d3d76ce117a.webp)

**每一层实现的协议各不相同**

![img](计算机网络.assets/1604025001203-7b104c36-1453-475e-a282-ff2e9cb19e2c.webp)

同样，TCP/IP五层协议的通信方式也是对等通信:

![image.png](计算机网络.assets/1604065635582-1a4e62ba-bdfa-45db-8a56-0302ff9a8020.png)

**各层传输单位**

应用层：报文

传输层：报文段

网络层：IP数据报/分组

数据链路层：帧

物理层：比特流

# 三、HTTP

## 1.HTTP概述

HTTP是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用80端口。它使用TCP作为传输层协议，保证了数据传输的可靠性。

1. HTTP优点
   - 支持客户端/服务器模式
   - **简单快速**:客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
   - **无连接**:无连接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开链接，采用这种方式可以节省传输时间。
   - **无状态**: HTTP协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。
   - **灵活**:HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
2. HTTP缺点
   - **无状态**:HTTP是一个无状态的协议，HTTP服务器不会保存关于客户的任何信息。
   - **明文传输**:协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
   - **不安全**
     - 通信使用明文(不加密)，内容可能会被窃听
     - 不验证通信方的身份，因此有可能遭遇伪装无法证明
     - 报文的完整性，所以有可能已遭篡改

## 2.HTTP性能

HTTP协议是基于**TCP/IP**，并且使用了**请求-应答的通信模式**，所以性能的关键就在这两点里。

### 1.长连接

HTTP协议有两种连接模式，一种是持续连接，一种是非连续连接。

- 非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。
- 持续连接下，TCP连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立TCP连接三次握手时所花费的时间。

对于不同版本的才有不同的连接方式：

- 在HTTP/1.0每发起一个请求，都要新建一次TCP连接（三次握手)，而且是**串行请求**，做了无畏的TCP连接建立和断开，**增加了通信开销**。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live来要求服务器不要关闭TCP连接。

- 在HTTP/1.1提出了**长连接**的通信方式，也叫持久连接。这种方式的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立6个持久连接。

  ![img](计算机网络.assets/1604065902281-b98a486c-5442-4d0b-b58d-00aab296ce1a.png)

### 2.管道网络传输

HTTP/1.1采用了长连接的方式，这使得管道(pipeline)网络传输成为了可能。

管道(pipeline)网络传输是指:可以在同一个TCP连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为**队头堵塞**。

### 3.对头堵塞

HTTP传输的报文必须是一发—收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。

**对头堵塞的解决方案：**

1. 并发连接:对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。
2. 域名分片:将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。

## 3.HTTP请求报文与响应报文

### 1.请求报文

请求报文由四部分组成：

- 请求⾏ 
  - 请求方法字段
  - 请求URI
  - 协议版本
- 请求头部 
  - 由关键字/值对组成，每行一对。
  - User-Agent: 产生请求的浏览器类型
  - Accept：客户端可识别的内容类型列表
  - Host: 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。
- 空⾏
- 请求体 ：post、put等携带的数据

### 2.请求方法字段

- GET: 向服务器获取数据；
- POST：将实体提交到指定的资源，通常会造成服务器资源的修改；
- PUT：上传文件，更新数据；
- DELETE：删除服务器上的对象；
- HEAD：获取报文首部，与GET相比，不返回报文主体部分；
- OPTIONS：询问支持的请求方法，用来跨域请求；
- CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；
- TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。

### 3.响应报文

- 响应行
  - 协议版本
  - 状态码
  - 状态码的原因短语
- 响应头
  - 由响应首部组成
  - Content-Type: text/html
- 空行
- 响应体:服务器的响应数据

## 4. HTTP 协议版本

### 1.HTTP1.0

- 非持续连接
- 串行请求

在HTTP/1.0每发起一个请求，都要新建一次TCP连接（三次握手)，而且是**串行请求**，做了无畏的TCP连接建立和断开，**增加了通信开销**。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live来要求服务器不要关闭TCP连接。

### 2.HTTP 1.1

HTTP 1.1版本较之前的1.o版本又有了更大的更新，它进一步完善了HTTP协议，现在仍然有在使用，它主要有以下更新:

#### 持久连接（长连接）

该版本之前的版本所建立的都是短连接，该版本引入了持久连接的概念，就是TCP连接默认是不关闭的，**建立一个TCP连接，就可以发送多个请求**，减少了建立和关闭连接的消耗和延迟。
在请求头设置一个非标准的Connection字段: **Connection: keep-alive**就可以进行长连接，这个字段要求服务器不要关闭TCP连接，服务器同样会回应这个字段。如果想要关闭TCP连接，就要在请求中设置字段:Connection: false

#### 管道机制

该版本还引入了管道机制，即在一个TCP连接里，客户端可以同时发送多个请求，不需要等收到上一个请求回应，就可以发送新的请求，但是请求的响应还是按照请求发送的顺序返回的，这样就进一步提高了HTTP协议的效率

#### 分块传输编码

分块传输编码:在HTTP1.0版本中，如果在服务器端遇到较为耗费时间的操作，那么需要等到这一操作全部完成后，才会向客户端发送数据，这段等待时间很影响性能和客户体验。多以使用**分块传输编码**，只要请求或者回应的头部信息有Transfer-Encoding字段:**Transfer-Encoding: chunked**，就表明回应将由数量未定的数据块组成。每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了

#### 新的请求方法

PUT、PATCH、HEAD、OPTIONS、DELETE

#### 加入了缓存机制

- 强缓存
- 协商缓存

#### 请求头加入Host字段

客户端请求的头部信息加入了Host字段，用来指定服务器的域名，这样就可以区分同一个物理主机中的不同虚拟主机的域名

#### HTTP1.1存在的问题—队头堵塞

HTTP/1.1默认使用了持久连接，多个请求可以复用同一个TCP连接，但是在同一个TCP连接里面，数据请求的通信次序是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许多请求排队等待的情况，这种情况被称为“队头堵塞”。队头阻塞会导致持久连接在达到最大数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

### 3.HTTP 2.0

#### 理解概念

- **流(stream)** :已建立连接上的双向字节流。
- **消息**:与逻辑消息对应的完整的一系列数据帧。
- **帧(frame)** : HTTP2.0通信的最小单位，每个帧包含帧头部，至少也**会标识出当前帧所属的流(stream id)**。

#### 二进制协议

HTTP/2是一个二进制协议。在HTTP/1.1版中，报文的头信息必须是文本(ASCIl编码)，数据体可以是文本，也可以是二进制。HTTP/2则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。帧的概念是它实现多路复用的基础。

#### 多路复用

HTTP/2 实现了多路复用，HTTP/2仍然复用TCP连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序——发送，这样就避免了"队头堵塞"的问题。

**数据流**

HTTP/2使用了数据流的概念，因为HTTP/2的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求(流)。HTTP/2将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。

#### 头信息压缩

HTTP/2实现了头信息压缩，由于HTTP 1.1协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用gzip或compress 压缩后再发送;另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。

#### 服务器推送

HTTP/2允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2下服务器主动推送的是静态资源，和 WebSocket以及使用SSE等方式向客户端发送即时数据的推送是不同的。

#### HTTP2.0缺点—TCP队头阻塞

因为HTTP/2使用了多路复用，一般来说**同一域名下只需要使用一个TCP连接**。由于多个数据流使用同一个TCP连接，遵守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都会被阻塞。HTTP/2出现的这个问题是由于其使用TCP协议的问题，与它本身的实现其实并没有多大关系。

### 4.从HTTP 1.0 到 HTTP 2.0

#### 队头阻塞

从HTTP/1.1 开始，就存在着对头阻塞的问题。

**HTTP/2解决了HTTP的队头阻塞问题，但是并没有解决TCP队头阻塞问题！**

HTTP/1.1 相比较于 HTTP/1.0来说，最主要的改进就是引入了持久连接（keep-alive）

**所谓的持久连接就是：在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。**

![preview](计算机网络.assets/v2-0e958b1e78485844a2e19cf1480028a1_r.jpg)

引入了持久连接之后，在性能方面，HTTP协议有了明显的提升。

HTTP/1.1允许在持久连接上使用请求管道，是相对于持久连接的又一性能优化。

所谓请求管道，就是在HTTP响应到达之前，可以将多条请求放入队列，当第一条HTTP请求通过网络流向服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。

![preview](计算机网络.assets/v2-a4c685c4c76546a3353b127824790e38_r.jpg)

**但是，对于管道连接还是有一定的限制和要求的，其中一个比较关键的就是服务端必须按照与请求相同的顺序回送HTTP响应。**

这也就意味着，如果一个响应返回发生了延迟，那么其后续的响应都会被延迟，直到队头的响应送达。这就是所谓的**HTTP队头阻塞**。

但是HTTP队头阻塞的问题在HTTP/2中得到了有效的解决。**HTTP/2废弃了管道化的方式**，而是创新性的引入了帧、消息和数据流等概念。**客户端和服务器可以把 HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。**

![preview](计算机网络.assets/v2-322baf847d4fdde1b0bb35aa64e1dcd2_r.jpg)

**因为没有顺序了，所以就不需要阻塞了，就有效的解决了HTTP对头阻塞的问题。**

但是，HTTP/2仍然会存在对头阻塞的问题，那是因为HTTP/2其实还是依赖TCP协议实现的。

TCP传输过程中会把数据拆分为一个个**按照顺序**排列的数据包，这些数据包通过网络传输到了接收端，接收端再**按照顺序**将这些数据包组合成原始数据，这样就完成了数据传输。

但是如果其中的某一个数据包没有按照顺序到达，接收端会一直保持连接等待数据包返回，这时候就会阻塞后续请求。这就发生了**TCP队头阻塞**。

HTTP/1.1的管道化持久连接也是使得同一个TCP链接可以被多个HTTP使用，但是HTTP/1.1中规定一个域名可以有6个TCP连接。而HTTP/2中，同一个域名只是用一个TCP连接。

所以，**在HTTP/2中，TCP对头阻塞造成的影响会更大**，因为HTTP/2的多路复用技术使得多个请求其实是基于同一个TCP连接的，那如果某一个请求造成了TCP队头阻塞，那么多个请求都会受到影响。

### 4.HTTP 3.0

HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。

![img](计算机网络.assets/1604068246276-9b0f553d-3c6e-43a3-8185-8565f9fa1fb4.webp)

1．流量控制、传输可靠性功能:QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。

2．集成TLS加密功能:目前QUIC使用TLS1.3，减少了握手所花费的RTT数。

3．多路复用:同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。

# 四、HTTPS

## 1.什么是HTTPS协议？

超文本传输安全协议(Hypertext Transfer ProtocolSecure，简称:HTTPS)是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

![img](计算机网络.assets/1603965685749-8cc21a1b-4277-42b1-aeed-18978c1cdb95.png)

HTTP协议采用**明文传输**信息，存在**信息窃听**、**信息篡改**和**信息劫持**的风险，而协议TLS/SSL具有**身份验证**、**信息加密**和**完整性校验**的功能，可以避免此类问题发生。
安全层的主要职责就是**对发起的HTTP请求的数据进行加密操作**和对**接收到的HTTP的内容进行解密操作**。

## 2.TLS/SSL的工作原理

**TLS/SSL**全称安全传输层协议(Transport Layer Security)，是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。
TLS/SSL的功能实现主要依赖三类基本算法:**散列函数hash、对称加密、非对称加密**。这三类算法的作用如下:

- 基于散列函数验证信息的完整性
- 对称加密算法采用协商的秘钥对数据加密。
- 非对称加密实现身份认证和秘钥协商

![img](计算机网络.assets/1603965685769-63a91dae-936d-42d3-8571-577cefa11e33.png)

### 1.散列函数hash

常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。
**特点**:在信息传输过程中，散列函数不能完全实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。

### 2.对称加密

对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。这就要用到非对称加密的方法。

常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。

**特点**:对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。

### 3.非对称加密

非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。

常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥(公开)和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。

特点:非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。

## 3.数字证书

现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。
为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash算法来对我们的公钥和其他信息进行加密生成一个信息摘要，然后让有公信力的认证中心(简称CA）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样我们才能保证数据的安全。

![img](计算机网络.assets/1603965685765-ffc9a525-ccad-43f0-bb25-8e17281d68fe.png)

## 4.HTTPS通信过程

HTTPS的通信过程如下:

- 第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
- 第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
- 第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的hash的值，用来供服务器检验。
- 第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash值来供客户端检验。
- 第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。

## 5.HTTPS的特点

HTTPS的**优点**如下:

- 使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器

- 使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性。

- 。HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本

HTTPS的**缺点**如下:

- HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂
- HTTPS协议握手阶段比较费时，增加页面的加载时间
- SSL证书是收费的，功能越强大的证书费用越高
- HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本
- SSL证书需要绑定IP，不能再同一个IP上绑定多个域名

## 6.HTTP和HTTPS协议的区别

HTTP和HTTPS协议的主要区别如下:

- HTTPS协议需要CA证书，费用较高;HTTP协议不需要
- HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议
- ·使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS的协议端口是443。
- HTTP协议连接很简单，是无状态的;HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全

## 1. 通信基本原理

**通信必要条件**

- 主机之间需要有传输介质
- 主机上必须有网卡设备
- 主机之间需要有协商网络速率

![image-20220129234215065](https://gitee.com/wayliuhaha/pic-go-drawing-bed/raw/master/img/image-20220129234215065.png)

## 2.网络通讯方式

- 交换机通讯
- 路由器通讯

![image-20220129234818063](https://gitee.com/wayliuhaha/pic-go-drawing-bed/raw/master/img/image-20220129234818063.png)

## 3.网络层次模型

**OSI 七层模型**

1. 应用层：用户与网络的接口
2. 表示层：数据加密、转换、压缩
3. 会话层：控制网络连接建立与终止
4. 传输层：控制数据传输可靠性
5. 网络层：确定目标网络
6. 数据链路层：确定目标主机
7. 物理层：各种物理设备与标准



**TCP/IP 五层模型**

1. 应用层
2. 传输层
3. 网络层
4. 数据链路层
5. 物理层

## 4.数据封装与封装

1. 应用层—— data
2. 传输层——目标端口 | 源端口 | data
3. 网络层——目标IP | 源IP | 目标端口 | 源端口 | data
4. 数据链路层——目标Mac | 源Mac | 目标IP | 源IP | 目标端口 | 源端口 | data
5. 物理层——10001010（二进制数据）

## 5.TCP三次握手与四次挥手

**TCP 协议**

- TCP 属于传输层协议
- TCP 是面向连接的协议
- TCP 用于处理实时通信

![image-20220130220030778](https://gitee.com/wayliuhaha/pic-go-drawing-bed/raw/master/img/image-20220130220030778.png)

**常见控制字段**

- SYN=1 表示请求建立连接
- FIN=1 表示请求断开连接
- ACK=1 表示数据信息确认

**三次握手**

![image-20220130220614610](https://gitee.com/wayliuhaha/pic-go-drawing-bed/raw/master/img/image-20220130220614610.png)

**四次挥手**

![image-20220130220921209](https://gitee.com/wayliuhaha/pic-go-drawing-bed/raw/master/img/image-20220130220921209.png)

- 客户端发送断开请求给服务端
- 服务端回复消息确认
- 服务端回复断开连接请求给客户端
- 客户端回复消息确认

**TCP 协议总结**

- TCP 处于传输层，基于端口，面向连接
- 主机之间要想通信需要先建立双向数据通道
- TCP 的握手和挥手本质上都是四次

## 6.创建TCP通信

**通信过程**

- 创建服务器：接收和回写客户端数据
- 创建客户端：发送和接收服务端数据
- 数据传输：内置服务事件和方法读写数据

**通信事件&方法**

- listening 事件：调用server.listen 方法之后触发
- connection 事件：新的连接建立时触发
- close 事件：当server关闭时触发
- error 事件：当错误出现的时候触发
- data 事件：当接收到数据时触发该事件
- write方法：在socket 上发送数据，默认时UTF8编码
- end 操作：当socket的一端发送FIN包时触发，结束可读端

```
// 1.server.js
const net = require('net')

// 创建服务端实例
const server = net.createServer()

const PORT = 1234
const HOST = 'localhost'

server.listen(PORT, HOST)

server.on('listening', () => {
    console.log(`服务端已经开启在 ${HOST} : ${PORT}`)
})

// 接收消息 回写消息
server.on('connection', (socket) => {
    socket.on('data', chunk => {
        const msg = chunk.toString()
        console.log(msg)
        
        // 回数据
        socket.write(Buffer.from('您好' + msg))
    })
})

server.on('close', () => {
    console.log('服务端关闭了')
})
```

```
// 2.client.js
const net = require('net')

const client = net.createConnection({
    port: 1234,
    host: 'localhost'
})

client.on('connect', () => {
    client.write('刘国威')
})

client.on('data', chunk => {
    console.log(chunk.toString())
})

client.on('error', err => {
    console.log(err)
})

client.on('close', () => {
    console.log('客户端断开连接')
})
```

## 7. TCP 粘包及解决

```
// 3.client-粘包及解决.js
const net = require('net')

const client = net.createConnection({
    port: 1234,
    host: 'localhost'
})

client.on('connect', () => {
    client.write('刘国威1')
    client.write('刘国威2')
    client.write('刘国威3')
    client.write('刘国威4')
})

client.on('data', chunk => {
    console.log(chunk.toString())
})

client.on('error', err => {
    console.log(err)
})

client.on('close', () => {
    console.log('客户端断开连接')
})
```

打印：您好刘国威1刘国威2刘国威3刘国威4

```
const net = require('net')

const client = net.createConnection({
    port: 1234,
    host: 'localhost'
})

let dataArr = [
    '刘国威2',
    '刘国威3',
    '刘国威4',
    '刘国威5'
]

client.on('connect', () => {
    client.write('刘国威1')
    for(let i=0; i<dataArr.length; i++) {
        (function(val, index) {
            setTimeout(() => {
                client.write(val)
            }, 1000 * (index + 1))
        })(dataArr[i], i)
    }
})

client.on('data', chunk => {
    console.log(chunk.toString())
})

client.on('error', err => {
    console.log(err)
})

client.on('close', () => {
    console.log('客户端断开连接')
})
```

- 您好刘国威1
- 您好刘国威2
- 您好刘国威3
- 您好刘国威4
- 您好刘国威5